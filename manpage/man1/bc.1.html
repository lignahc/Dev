<HTML><HEAD><TITLE>Manpage of bc</TITLE>
</HEAD><BODY>
<H1>bc</H1>
Section: User Commands  (1)<BR>Updated: .<BR><A HREF="#index">Index</A>
<BR />
<A HREF="http://localhost/cgi-bin/man/man2html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>이름</H2>

bc - 무한 정확도 계산기 언어
<A NAME="lbAC">&nbsp;</A>
<H2>문법</H2>

<B>bc</B> [ <B>-lws</B> ] [ <I> 화일 ...</I> ]
<A NAME="lbAD">&nbsp;</A>
<H2>버전 </H2>

이 맨페이지는 GNU bc 버전 1.03에 대한 것이다.
<A NAME="lbAE">&nbsp;</A>
<H2>설명</H2>

<B>bc</B> 는 대화형으로 문장을 실행하는 무한 정확도의 숫자를 지원하는
언어이며 약간 C 언어와 비슷한 문법을 가지고 있다.
명령행 옵션을 주면 표준 수학 라이브러리를 사용할 수 있다.
옵션을 주면 화일들을 처리하기에 앞서 수학 라이브러리가 정의된다.
<B>bc</B> 는 우선 명령에서 주어진 화일 순서대로 처리한다.
화일을 모두 처리한 후 <B>bc</B> 는 표준 입력을 읽는다.
모든 코드는 읽는 즉시 실행된다. ( 만약 화일 내의 코드에 처리를 중지하라는
명령이 있다면 <B>bc</B>는 표준입력에서 읽지 않을 것이다. )
<P>

<B>bc</B> 현재 버전에서는 전통적인 <B>bc</B> 기능과 POSIX 표준 이외의 
확장 기능을 포함하고 있다. 명령행 옵션을 주면 확장 기능에 대한 경고 메세지를
보여주고 처리를 무시하게 할 수 있다. 이 문서에서는 GNU 버전의 처리기에서
사용하는 언어를 설명한다. 확장 기능도 같이 설명한다.
<A NAME="lbAF">&nbsp;</A>
<H3>옵션</H3>

<DL COMPACT>
<DT>-l<DD>
표준 수학 라이브러리를 정의한다.
<DT>-w<DD>
POSIX <B>bc</B>에 대한 확장기능에 대하여 경고 메세지를 보여준다.
<DT>-s<DD>
POSIX <B>bc</B> 언어로만 작동하게 한다.
</DL>
<A NAME="lbAG">&nbsp;</A>
<H3>숫자</H3>

<B>bc</B>에서 가장 기본적인 요소는 바로 숫자이다. 숫자는 임의 자리의 정확도를
갖는 숫자이다. 정확도란 정수 부분과 분수 부분을 모두 포함한다.
모든 숫자는 내부적으로 10 진수 처리하며 10 진수로 계산이 이뤄진다.
(이번 버전에서는 나누기, 곱하기의 결과에 대하여 버림을 한다 )
숫자에는 두 가지 구성요소가 있는데 길이(length)와 스케일(scale)이 바로 그것이
다. 길이는 숫자의 유효 숫자 갯수이며 스케일은 소수점 이하의 자리수를 말한다.
예를 들자면:
<PRE>
<DL COMPACT><DT><DD> .000001  은 길이 6, 스케일 6 이다.
 1935.000 은 길이 7, 스케일 3 이다.
</DL>
</PRE>

<A NAME="lbAH">&nbsp;</A>
<H3>변수</H3>

숫자는 두 가지 형태의 변수, 일반 변수 또는 배열에 저장된다. 둘 다 모두 이름을
가진다. 이름은 문자 다음에 문자, 숫자, 언더스코어(_)를 쓰며 길이에는 제한이
없다.
arrays.  Both simple variables and array variables are named.  Names
begin with a letter followed by any number of letters, digits and
underscores.  All letters must be lower case.  (Full alpha-numeric
names are an extension. In POSIX <B>bc</B> all names are a single
lower case letter.)  The type of variable is clear by the context
because all array variable names will be followed by brackets ([]).
<P>

There are four special variables, <B>scale, ibase, obase,</B> and
<B>last</B>.  <B>scale</B> defines how some operations use digits after the
decimal point.  The default value of <B>scale</B> is 0. <B>ibase</B>
and <B>obase</B> define the conversion base for input and output
numbers.  The default for both input and output is base 10.
<B>last</B> (an extension) is a variable that has the value of the last
printed number.  These will be discussed in further detail where
appropriate.  All of these variables may have values assigned to them
as well as used in expressions.
<A NAME="lbAI">&nbsp;</A>
<H3>COMMENTS</H3>

Comments in <B>bc</B> start with the characters <B>/*</B> and end with
the characters <B>*/</B>.  Comments may start anywhere and appear as a
single space in the input.  (This causes comments to delimit other
input items.  For example, a comment can not be found in the middle of
a variable name.)  Comments include any newlines (end of line) between
the start and the end of the comment.
<A NAME="lbAJ">&nbsp;</A>
<H3>EXPRESSIONS</H3>

The numbers are manipulated by expressions and statements.  Since
the language was designed to be interactive, statements and expressions
are executed as soon as possible.  There is no &quot;main&quot; program.  Instead,
code is executed as it is encountered.  (Functions, discussed in
detail later, are defined when encountered.)
<P>

A simple expression is just a constant. <B>bc</B> converts constants
into internal decimal numbers using the current input base, specified
by the variable <B>ibase</B>. (There is an exception in functions.)
The legal values of <B>ibase</B> are 2 through 16 (F).  Assigning a
value outside this range to <B>ibase</B> will result in a value of 2
or 16.  Input numbers may contain the characters 0-9 and A-F. (Note:
They must be capitals.  Lower case letters are variable names.)
Single digit numbers always have the value of the digit regardless of
the value of <B>ibase</B>. (i.e. A = 10.)  For multi-digit numbers,
<B>bc</B> changes all input digits greater or equal to ibase to the
value of <B>ibase</B>-1.  This makes the number <B>FFF</B> always be
the largest 3 digit number of the input base.
<P>

Full expressions are similar to many other high level languages.
Since there is only one kind of number, there are no rules for mixing
types.  Instead, there are rules on the scale of expressions.  Every
expression has a scale.  This is derived from the scale of original
numbers, the operation performed and in many cases, the value of the
variable <B>scale</B>. Legal values of the variable <B>scale</B> are
0 to the maximum number representable by a C integer.
<P>

In the following descriptions of legal expressions, &quot;expr&quot; refers to a
complete expression and &quot;var&quot; refers to a simple or an array variable.
A simple variable is just a
<DL COMPACT><DT><DD>
<I>name</I>
</DL>

and an array variable is specified as
<DL COMPACT><DT><DD>
<I>name</I>[<I>expr</I>]
</DL>

Unless specifically
mentioned the scale of the result is the maximum scale of the
expressions involved.
<DL COMPACT>
<DT>- expr<DD>
The result is the negation of the expression.
<DT>++ var<DD>
The variable is incremented by one and the new value is the result of
the expression.
<DT>-- var<DD>
The variable
is decremented by one and the new value is the result of the
expression.
<DT>var ++<DD>
<BR>&nbsp;The&nbsp;result&nbsp;of&nbsp;the&nbsp;expression&nbsp;is&nbsp;the&nbsp;value&nbsp;of
the variable and then the variable is incremented by one.
<DT>var --<DD>
The result of the expression is the value of the variable and then
the variable is decremented by one.
<DT>expr + expr<DD>
The result of the expression is the sum of the two expressions.
<DT>expr - expr<DD>
The result of the expression is the difference of the two expressions.
<DT>expr * expr<DD>
The result of the expression is the product of the two expressions.
<DT>expr / expr<DD>
The result of the expression is the quotient of the two expressions.
The scale of the result is the value of the variable <B>scale</B>.
<DT>expr % expr<DD>
The result of the expression is the &quot;remainder&quot; and it is computed in the
following way.  To compute a%b, first a/b is computed to <B>scale</B>
digits.  That result is used to compute a-(a/b)*b to the scale of the
maximum of <B>scale</B>+scale(b) and scale(a).  If <B>scale</B> is set
to zero and both expressions are integers this expression is the
integer remainder function.
<DT>expr ^ expr<DD>
The result of the expression is the value of the first raised to the
second. The second expression must be an integer.  (If the second
expression is not an integer, a warning is generated and the
expression is truncated to get an integer value.)  The scale of the
result is <B>scale</B> if the exponent is negative.  If the exponent
is positive the scale of the result is the minimum of the scale of the
first expression times the value of the exponent and the maximum of
<B>scale</B> and the scale of the first expression.  (e.g. scale(a^b)
= min(scale(a)*b, max( <B>scale,</B> scale(a))).)  It should be noted
that expr^0 will always return the value of 1.
<DT>( expr )<DD>
This alters the standard precedence to force the evaluation of the
expression.
<DT>var = expr<DD>
The variable is assigned the value of the expression.
<DT>var &lt;op&gt;= expr<DD>
This is equivalent to &quot;var = var &lt;op&gt; expr&quot; with the exception that
the &quot;var&quot; part is evaluated only once.  This can make a difference if
&quot;var&quot; is an array.
</DL>
<P>

<BR>&nbsp;Relational&nbsp;expressions&nbsp;are&nbsp;a&nbsp;special&nbsp;kind&nbsp;of&nbsp;expression
that always evaluate to 0 or 1, 0 if the relation is false and 1 if
the relation is true.  These may appear in any legal expression.
(POSIX bc requires that relational expressions are used only in if,
while, and for statements and that only one relational test may be
done in them.)  The relational operators are
<DL COMPACT>
<DT>expr1 &lt; expr2<DD>
The result is 1 if expr1 is strictly less than expr2.
<DT>expr1 &lt;= expr2<DD>
The result is 1 if expr1 is less than or equal to expr2.
<DT>expr1 &gt; expr2<DD>
The result is 1 if expr1 is strictly greater than expr2.
<DT>expr1 &gt;= expr2<DD>
The result is 1 if expr1 is greater than or equal to expr2.
<DT>expr1 == expr2<DD>
The result is 1 if expr1 is equal to expr2.
<DT>expr1 != expr2<DD>
The result is 1 if expr1 is not equal to expr2.
</DL>
<P>

Boolean operations are also legal.  (POSIX <B>bc</B> does NOT have
boolean operations). The result of all boolean operations are 0 and 1
(for false and true) as in relational expressions.  The boolean
operators are:
<DL COMPACT>
<DT>!expr<DD>
The result is 1 if expr is 0.
<DT>expr &amp;&amp; expr<DD>
The result is 1 if both expressions are non-zero.
<DT>expr || expr<DD>
The result is 1 if either expression is non-zero.
</DL>
<P>

The expression precedence is as follows: (lowest to highest)
<PRE>
<DL COMPACT><DT><DD>|| operator, left associative
&amp;&amp; operator, left associative
! operator, nonassociative
Relational operators, left associative
Assignment operator, right associative
+ and - operators, left associative
*, / and % operators, left associative
^ operator, right associative
unary - operator, nonassociative
++ and -- operators, nonassociative
</DL>
</PRE>

<P>

This precedence was chosen so that POSIX compliant <B>bc</B> programs
will run correctly. This will cause the use of the relational and
logical operators to have some unusual behavior when used with
assignment expressions.  Consider the expression:
<DL COMPACT><DT><DD>
a = 3 &lt; 5
</DL>

<P>

Most C programmers would assume this would assign the result of &quot;3 &lt;
5&quot; (the value 1) to the variable &quot;a&quot;.  What this does in <B>bc</B> is
assign the value 3 to the variable &quot;a&quot; and then compare 3 to 5.  It is
best to use parenthesis when using relational and logical operators
with the assignment operators.
<P>

There are a few more special expressions that are provided in <B>bc</B>.
These have to do with user defined functions and standard
functions.  They all appear as &quot;<I>name</I><B>(</B><I>parameters</I><B>)</B>&quot;.
See the section on functions for user defined functions.  The standard
functions are:
<DL COMPACT>
<DT>length ( expression )<DD>
The value of the length function is the number of significant digits in the
expression.
<DT>read ( )<DD>
The read function (an extension) will read a number from the standard
input, regardless of where the function occurs.   Beware, this can
cause problems with the mixing of data and program in the standard input.
The best use for this function is in a previously written program that
needs input from the user, but never allows program code to be input
from the user.  The value of the read function is the number read from
the standard input using the current value of the variable 
<B>ibase</B> for the conversion base.
<DT>scale ( expression )<DD>
The value of the scale function is the number of digits after the decimal
point in the expression.
<DT>sqrt ( expression )<DD>
The value of the sqrt function is the square root of the expression.  If
the expression is negative, a run time error is generated.
</DL>
<A NAME="lbAK">&nbsp;</A>
<H3>STATEMENTS</H3>

Statements (as in most algebraic languages) provide the sequencing of
expression evaluation.  In <B>bc</B> statements are executed &quot;as soon
as possible.&quot;  Execution happens when a newline in encountered and
there is one or more complete statements.  Due to this immediate
execution, newlines are very important in <B>bc</B>. In fact, both a
semicolon and a newline are used as statement separators.  An
improperly placed newline will cause a syntax error.  Because newlines
are statement separators, it is possible to hide a newline by using
the backslash character.  The sequence &quot;\&lt;nl&gt;&quot;, where &lt;nl&gt; is the
newline appears to <B>bc</B> as whitespace instead of a newline.  A
statement list is a series of statements separated by semicolons and
newlines.  The following is a list of <B>bc</B> statements and what
they do: (Things enclosed in brackets ([]) are optional parts of the
statement.)
<DL COMPACT>
<DT>expression<DD>
This statement does one of two things.  If the expression starts with
&quot;&lt;variable&gt; &lt;assignment&gt; ...&quot;, it is considered to be an assignment
statement.  If the expression is not an assignment statement, the
expression is evaluated and printed to the output.  After the number
is printed, a newline is printed.  For example, &quot;a=1&quot; is an assignment
statement and &quot;(a=1)&quot; is an expression that has an embedded
assignment.  All numbers that are printed are printed in the base
specified by the variable <B>obase</B>. The legal values for <B>
obase</B> are 2 through BC_BASE_MAX.  (See the section LIMITS.)  For
bases 2 through 16, the usual method of writing numbers is used.  For
bases greater than 16, <B>bc</B> uses a multi-character digit method
of printing the numbers where each higher base digit is printed as a
base 10 number.  The multi-character digits are separated by spaces.
Each digit contains the number of characters required to represent the
base ten value of &quot;obase-1&quot;.  Since numbers are of arbitrary
precision, some numbers may not be printable on a single output line.
These long numbers will be split across lines using the &quot;\&quot; as the
last character on a line.  The maximum number of characters printed
per line is 70.  Due to the interactive nature of <B>bc</B> printing
a number cause the side effect of assigning the printed value the the
special variable <B>last</B>. This allows the user to recover the
last value printed without having to retype the expression that
printed the number.  Assigning to <B>last</B> is legal and will
overwrite the last printed value with the assigned value.  The newly
assigned value will remain until the next number is printed or another
value is assigned to <B>last</B>.  (Some installations may allow the 
use of a single period (.) which is not part of a number as a short
hand notation for for <B>last</B>.)
<DT>string<DD>
The string is printed to the output.  Strings start with a double quote
character and contain all characters until the next double quote character.
All characters are take literally, including any newline.  No newline
character is printed after the string.
<DT><B>print</B> list<DD>
The print statement (an extension) provides another method of output.
The &quot;list&quot; is a list of strings and expressions separated by commas.
Each string or expression is printed in the order of the list.  No
terminating newline is printed.  Expressions are evaluated and their
value is printed and assigned the the variable <B>last</B>. Strings
in the print statement are printed to the output and may contain
special characters.  Special characters start with the backslash
character (\).  The special characters recognized by <B>bc</B> are
&quot;a&quot; (alert or bell), &quot;b&quot; (backspace), &quot;f&quot; (form feed), &quot;n&quot; (newline),
&quot;r&quot; (carriage return), &quot;q&quot; (double quote), &quot;t&quot; (tab), and &quot;\&quot; (backslash).
Any other character following the backslash will be ignored.  
<DT>{ statement_list }<DD>
This is the compound statement.  It allows multiple statements to be
grouped together for execution.
<DT><B>if</B> ( expression ) <B>then</B> statement1 [<B>else</B> statement2]<DD>
The if statement evaluates the expression and executes statement1 or
statement2 depending on the value of the expression.  If the expression
is non-zero, statement1 is executed.  If statement2 is present and
the value of the expression is 0, then statement2 is executed.  (The
else clause is an extension.)
<DT><B>while</B> ( expression ) statement<DD>
The while statement will execute the statement while the expression
is non-zero.  It evaluates the expression before each execution of
the statement.   Termination of the loop is caused by a zero
expression value or the execution of a break statement.
<DT><B>for</B> ( [expression1] ; [expression2] ; [expression3] ) statement<DD>
The for statement controls repeated execution of the statement.  
Expression1 is evaluated before the loop.  Expression2 is evaluated
before each execution of the statement.  If it is non-zero, the statement
is evaluated.  If it is zero, the loop is terminated.  After each
execution of the statement, expression3 is evaluated before the reevaluation
of expression2.  If expression1 or expression3 are missing, nothing is
evaluated at the point they would be evaluated.
If expression2 is missing, it is the same as substituting
the value 1 for expression2.  (The optional expressions are an
extension. POSIX <B>bc</B> requires all three expressions.)
The following is equivalent code for the for statement:
<PRE>
<DL COMPACT><DT><DD>expression1;
while (expression2) {
   statement;
   expression3;
}
</DL>
</PRE>

<DT><B>break</B><DD>
This statement causes a forced exit of the most recent enclosing while
statement or for statement.
<DT><B>continue</B><DD>
The continue statement (an extension)  causes the most recent enclosing
for statement to start the next iteration.
<DT><B>halt</B><DD>
The halt statement (an extension) is an executed statement that causes
the <B>bc</B> processor to quit only when it is executed.  For example,
&quot;if (0 == 1) halt&quot; will not cause <B>bc</B> to terminate because the halt is
not executed.
<DT><B>return</B><DD>
Return the value 0 from a function.  (See the section on functions.)
<DT><B>return</B> ( expression )<DD>
Return the value of the expression from a function.  (See the section on 
functions.)
</DL>
<A NAME="lbAL">&nbsp;</A>
<H3>PSEUDO STATEMENTS</H3>

These statements are not statements in the traditional sense.  They are
not executed statements.  Their function is performed at &quot;compile&quot; time.
<DL COMPACT>
<DT><B>limits</B><DD>
Print the local limits enforced by the local version of <B>bc</B>.  This
is an extension.
<DT><B>quit</B><DD>
When the quit statement is read, the <B>bc</B> processor
is terminated, regardless of where the quit statement is found.  For
example, &quot;if (0 == 1) quit&quot; will cause <B>bc</B> to terminate.
<DT><B>warranty</B><DD>
Print a longer warranty notice.  This is an extension.
</DL>
<A NAME="lbAM">&nbsp;</A>
<H3>FUNCTIONS</H3>

Functions provide a method of defining a computation that can be executed
later.  Functions in 
<B>bc</B>

always compute a value and return it to the caller.  Function definitions
are &quot;dynamic&quot; in the sense that a function is undefined until a definition
is encountered in the input.  That definition is then used until another
definition function for the same name is encountered.  The new definition
then replaces the older definition.  A function is defined as follows:
<PRE>
<DL COMPACT><DT><DD><B>define </B><I>name </I><B>( </B><I>parameters </I><B>) { </B><I>newline
    auto_list   statement_list </I><B>}</B>
</DL>
</PRE>

A function call is just an expression of the form
&quot;<I>name</I><B>(</B><I>parameters</I><B>)</B>&quot;.
<P>

Parameters are numbers or arrays (an extension).  In the function definition,
zero or more parameters are defined by listing their names separated by
commas.  Numbers are only call by value parameters.  Arrays are only
call by variable.  Arrays are specified in the parameter definition by
the notation &quot;<I>name</I><B>[]</B>&quot;.   In the function call, actual parameters
are full expressions for number parameters.  The same notation is used
for passing arrays as for defining array parameters.  The named array is
passed by variable to the function.  Since function definitions are dynamic,
parameter numbers and types are checked when a function is called.  Any
mismatch in number or types of parameters will cause a runtime error.
A runtime error will also occur for the call to an undefined function.
<P>

The <I>auto_list</I>is an optional list of variables that are for
&quot;local&quot; use.  The syntax of the auto list (if present) is &quot;<B>auto
</B><I>name</I>, ... ;&quot;.  (The semicolon is optional.)  Each <I>name</I> is
the name of an auto variable.  Arrays may be specified by using the
same notation as used in parameters.  These variables have their
values pushed onto a stack at the start of the function.  The
variables are then initialized to zero and used throughout the
execution of the function.  At function exit, these variables are
popped so that the original value (at the time of the function call)
of these variables are restored.  The parameters are really auto
variables that are initialized to a value provided in the function
call.  Auto variables are different than traditional local variables
in the fact that if function A calls function B, B may access function
A's auto variables by just using the same name, unless function B has
called them auto variables.  Due to the fact that auto variables and
parameters are pushed onto a stack, <B>bc</B> supports recursive functions.
<P>

The function body is a list of <B>bc</B> statements.  Again, statements
are separated by semicolons or newlines.  Return statements cause the
termination of a function and the return of a value.  There are two
versions of the return statement.  The first form, &quot;<B>return</B>&quot;, returns
the value 0 to the calling expression.  The second form, 
&quot;<B>return ( </B><I>expression </I><B>)</B>&quot;, computes the value of the expression
and returns that value to the calling expression.  There is an implied
&quot;<B>return (0)</B>&quot; at the end of every function.  This allows a function
to terminate and return 0 without an explicit return statement.
<P>

Functions also change the usage of the variable <B>ibase</B>.  All
constants in the function body will be converted using the value of
<B>ibase</B> at the time of the function call.  Changes of <B>ibase</B>
will be ignored during the execution of the function except for the
standard function <B>read</B>, which will always use the current value
of <B>ibase</B> for conversion of numbers.
<A NAME="lbAN">&nbsp;</A>
<H3>MATH LIBRARY</H3>

If <B>bc</B> is invoked with the <B>-l</B> option, a math library is preloaded
and the default scale is set to 20.   The math functions will calculate their
results to the scale set at the time of their call.  
The math library defines the following functions:
<DL COMPACT>
<DT>s (<I>x</I>)<DD>
The sine of x in radians.
<DT>c (<I>x</I>)<DD>
The cosine of x in radians.
<DT>a (<I>x</I>)<DD>
The arctangent of x.
<DT>l (<I>x</I>)<DD>
The natural logarithm of x.
<DT>e (<I>x</I>)<DD>
The exponential function of raising e to the value x.
<DT>j (<I>n,x</I>)<DD>
The bessel function of integer order n of x.
</DL>
<A NAME="lbAO">&nbsp;</A>
<H3>EXAMPLES</H3>

In /bin/sh,  the following will assign the value of &quot;pi&quot; to the shell
variable <B>pi</B>.
<DL COMPACT><DT><DD>
<TT>
pi=$(echo &quot;scale=10; 4*<A HREF="http://localhost/cgi-bin/man/man2html?1+a">a</A>(1)&quot; | bc -l)
</TT>
</DL>

<P>

The following is the definition of the exponential function used in the
math library.  This function is written in POSIX <B>bc</B>.
<PRE>
<DL COMPACT><DT><DD><TT>
scale = 20

/* Uses the fact that e^x = (e^(x/2))^2
   When x is small enough, we use the series:
     e^x = 1 + x + x^2/2! + x^3/3! + ...
*/

define e(x) {
  auto  a, d, e, f, i, m, v, z

  /* Check the sign of x. */
  if (x&lt;0) {
    m = 1
    x = -x
  } 

  /* Precondition x. */
  z = scale;
  scale = 4 + z + .44*x;
  while (x &gt; 1) {
    f += 1;
    x /= 2;
  }

  /* Initialize the variables. */
  v = 1+x
  a = x
  d = 1

  for (i=2; 1; i++) {
    e = (a *= x) / (d *= i)
    if (e == 0) {
      if (f&gt;0) while (f--)  v = v*v;
      scale = z
      if (m) return (1/v);
      return (v/1);
    }
    v += e
  }
}
</TT>
</DL>
</PRE>

<P>

The following is code that uses the extended features of <B>bc</B> to
implement a simple program for calculating checkbook balances.  This
program is best kept in a file so that it can be used many times 
without having to retype it at every use.
<PRE>
<DL COMPACT><DT><DD><TT>
scale=2
print &quot;\nCheck book program!\n&quot;
print &quot;  Remember, deposits are negative transactions.\n&quot;
print &quot;  Exit by a 0 transaction.\n\n&quot;

print &quot;Initial balance? &quot;; bal = read()
bal /= 1
print &quot;\n&quot;
while (1) {
  &quot;current balance = &quot;; bal
  &quot;transaction? &quot;; trans = read()
  if (trans == 0) break;
  bal -= trans
  bal /= 1
}
quit
</TT>
</DL>
</PRE>

<P>

The following is the definition of the recursive factorial function.
<PRE>
<DL COMPACT><DT><DD><TT>
define f (x) {
  if (x &lt;= 1) return (1);
  return (f(x-1) * x);
}
</TT>
</DL>
</PRE>

<A NAME="lbAP">&nbsp;</A>
<H3>DIFFERENCES</H3>

This version of 
<B>bc</B>

was implemented from the POSIX P1003.2/D11 draft and contains
several differences and extensions relative to the draft and
traditional implementations.
It is not implemented in the traditional way using
<I><A HREF="http://localhost/cgi-bin/man/man2html?1+dc">dc</A>(1).</I>

This version is a single process which parses and runs a byte code
translation of the program.  There is an &quot;undocumented&quot; option (-c)
that causes the program to output the byte code to
the standard output instead of running it.  It was mainly used for
debugging the parser and preparing the math library.
<P>

A major source of differences is
extensions, where a feature is extended to add more functionality and
additions, where new features are added. 
The following is the list of differences and extensions.
<DL COMPACT>
<DT>LANG<DD>
This version does not conform to the POSIX standard in the processing
of the LANG environment variable and all environment variables starting
with LC_.
<DT>names<DD>
Traditional and POSIX
<B>bc</B>

have single letter names for functions, variables and arrays.  They have
been extended to be multi-character names that start with a letter and
may contain letters, numbers and the underscore character.
<DT>Strings<DD>
Strings are not allowed to contain NUL characters.  POSIX says all characters
must be included in strings.
<DT>last<DD>
POSIX <B>bc</B> does not have a <B>last</B> variable.  Some implementations
of <B>bc</B> use the period (.) in a similar way.  
<DT>comparisons<DD>
POSIX <B>bc</B> allows comparisons only in the if statement, the while
statement, and the second expression of the for statement.  Also, only
one relational operation is allowed in each of those statements.
<DT>if statement, else clause<DD>
POSIX <B>bc</B> does not have an else clause.
<DT>for statement<DD>
POSIX <B>bc</B> requires all expressions to be present in the for statement.
<DT>&amp;&amp;, ||, !<DD>
POSIX <B>bc</B> does not have the logical operators.
<DT>read function<DD>
POSIX <B>bc</B> does not have a read function.
<DT>print statement<DD>
POSIX <B>bc</B> does not have a print statement .
<DT>continue statement<DD>
POSIX <B>bc</B> does not have a continue statement.
<DT>array parameters<DD>
POSIX <B>bc</B> does not have array parameters.  Other implementations
of <B>bc</B> may have call by value array parameters.
<DT>=+, =-, =*, =/, =%, =^<DD>
POSIX <B>bc</B> does not require these &quot;old style&quot; assignment operators to
be defined.  This version may allow these &quot;old style&quot; assignments.  Use
the limits statement to see if the installed version supports them.  If
it does support the &quot;old style&quot; assignment operators, the statement
&quot;a =- 1&quot; will decrement <B>a</B> by 1 instead of setting <B>a</B> to the
value -1.
<DT>spaces in numbers<DD>
Other implementations of <B>bc</B> allow spaces in numbers.  For example,
&quot;x=1 3&quot; would assign the value 13 to the variable x.  The same statement
would cause a syntax error in this version of <B>bc</B>.
<DT>errors and execution<DD>
This implementation varies from other implementations in terms of what
code will be executed when syntax and other errors are found in the
program.  If a syntax error is found in a function definition, error
recovery tries to find the beginning of a statement and continue to
parse the function.  Once a syntax error is found in the function, the
function will not be callable and becomes undefined.
Syntax errors in the interactive execution code will invalidate the
current execution block.  The execution block is terminated by an
end of line that appears after a complete sequence of statements.
For example, 
<PRE>
<DL COMPACT><DT><DD>a = 1
b = 2
</DL>
</PRE>

has two execution blocks and
<PRE>
<DL COMPACT><DT><DD>{ a = 1
  b = 2 }
</DL>
</PRE>

has one execution block.  Any runtime error will terminate the execution
of the current execution block.  A runtime warning will not terminate the
current execution block.
<DT>Interrupts<DD>
During an interactive session, the SIGINT signal (usually generated by
the control-C character from the terminal) will cause execution of the
current execution block to be interrupted.  It will display a &quot;runtime&quot;
error indicating which function was interrupted.  After all runtime
structures have been cleaned up, a message will be printed to notify the
user that <B>bc</B> is ready for more input.  All previously defined functions
remain defined and the value of all non-auto variables are the value at
the point of interruption.  All auto variables and function parameters
are removed during the
clean up process.  During a non-interactive
session, the SIGINT signal will terminate the entire run of <B>bc</B>.
</DL>
<A NAME="lbAQ">&nbsp;</A>
<H3>LIMITS</H3>

The following are the limits currently in place for this 
<B>bc</B>

processor.  Some of them may have been changed by an installation.
Use the limits statement to see the actual values.
<DL COMPACT>
<DT>BC_BASE_MAX<DD>
The maximum output base is currently set at 999.  The maximum input base
is 16.
<DT>BC_DIM_MAX<DD>
This is currently an arbitrary limit of 65535 as distributed.  Your
installation may be different.
<DT>BC_SCALE_MAX<DD>
The number of digits after the decimal point is limited to INT_MAX digits.
Also, the number of digits before the decimal point is limited to INT_MAX
digits.
<DT>BC_STRING_MAX<DD>
The limit on the number of characters in a string is INT_MAX characters.
<DT>exponent<DD>
The value of the exponent in the raise operation (^) is limited to LONG_MAX.
<DT>multiply<DD>
The multiply routine may yield incorrect results if a number
has more than LONG_MAX / 90 total digits.  For 32 bit longs, this number is
23,860,929 digits.
<DT>code size<DD>
Each function and the &quot;main&quot; program are limited to 16384 bytes of
compiled byte code each.  This limit (BC_MAX_SEGS) can be easily changed
to have more than 16 segments of 1024 bytes.
<DT>variable names<DD>
The current limit on the number of unique names is 32767 for each of
simple variables, arrays and functions.
</DL>
<A NAME="lbAR">&nbsp;</A>
<H2>FILES</H2>

In most installations, <B>bc</B> is completely self-contained.
Where executable size is of importance or the C compiler does
not deal with very long strings, <B>bc</B> will read
the standard math library from the file /usr/local/lib/libmath.b.
(The actual location may vary.  It may be /lib/libmath.b.)
<A NAME="lbAS">&nbsp;</A>
<H2>DIAGNOSTICS</H2>

If any file on the command line can not be opened, <B>bc</B> will report
that the file is unavailable and terminate.  Also, there are compile
and run time diagnostics that should be self-explanatory.
<A NAME="lbAT">&nbsp;</A>
<H2>BUGS</H2>

Error recovery is not very good yet.
<A NAME="lbAU">&nbsp;</A>
<H2>AUTHOR</H2>

<PRE>
Philip A. Nelson
<A HREF="mailto:phil@cs.wwu.edu">phil@cs.wwu.edu</A>
</PRE>

<A NAME="lbAV">&nbsp;</A>
<H2>ACKNOWLEDGEMENTS</H2>

The author would like to thank Steve Sommars (<A HREF="mailto:Steve.Sommars@att.com">Steve.Sommars@att.com</A>) for
his extensive help in testing the implementation.  Many great suggestions
were given.  This is a much better product due to his involvement.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">이름</A><DD>
<DT><A HREF="#lbAC">문법</A><DD>
<DT><A HREF="#lbAD">버전 </A><DD>
<DT><A HREF="#lbAE">설명</A><DD>
<DL>
<DT><A HREF="#lbAF">옵션</A><DD>
<DT><A HREF="#lbAG">숫자</A><DD>
<DT><A HREF="#lbAH">변수</A><DD>
<DT><A HREF="#lbAI">COMMENTS</A><DD>
<DT><A HREF="#lbAJ">EXPRESSIONS</A><DD>
<DT><A HREF="#lbAK">STATEMENTS</A><DD>
<DT><A HREF="#lbAL">PSEUDO STATEMENTS</A><DD>
<DT><A HREF="#lbAM">FUNCTIONS</A><DD>
<DT><A HREF="#lbAN">MATH LIBRARY</A><DD>
<DT><A HREF="#lbAO">EXAMPLES</A><DD>
<DT><A HREF="#lbAP">DIFFERENCES</A><DD>
<DT><A HREF="#lbAQ">LIMITS</A><DD>
</DL>
<DT><A HREF="#lbAR">FILES</A><DD>
<DT><A HREF="#lbAS">DIAGNOSTICS</A><DD>
<DT><A HREF="#lbAT">BUGS</A><DD>
<DT><A HREF="#lbAU">AUTHOR</A><DD>
<DT><A HREF="#lbAV">ACKNOWLEDGEMENTS</A><DD>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 08:06:55 GMT, March 25, 2004
</BODY>
</HTML>
