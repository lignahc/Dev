<HTML><HEAD><TITLE>Manpage of CONSOLE_CODES</TITLE>
</HEAD><BODY>
<H1>CONSOLE_CODES</H1>
Section: Linux Programmer's Manual (4)<BR>Updated: October 31, 1996<BR><A HREF="#index">Index</A>
<BR />
<A HREF="http://localhost/cgi-bin/man/man2html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

console_codes - 리눅스 콘솔 제어문자와 제어 순서 구조
<A NAME="lbAC">&nbsp;</A>
<H2>DESCRIPTION</H2>

리눅스 콘솔은 VT102와 ECMA-48/ISO6429/ANSI X3.64 터미널 콘트롤의 
많은 부분이 적용된다. 여기에 칼라 팔레트나 문자 설정 맵핑 등의 변화 같은
비공식적인 모드의 시퀀스가 더해진다.
아래 표에서, 두번째 컬럼은 주어진 함수에 대해 ECMA-48이나 DEC
mnemonic (DEC 접두사가 붙어있는 글씨)를 주었다.
mnemonic이 없는 시퀀스는 ECMA-48나 VT102도 아니다.
<P>

모든 출력과정이 끝나고 문자들이 콘솔 드라이버에 
실제 프린팅을 위해 도착한 후에, 가장 먼저 일어나는 일은
진행을 위해 쓰인 코드들이 프린팅을 위한 코드들로 바뀌는 것이다.
<P>

콘솔이 UTF-8모드라면, 들어오는 바이트들은 처음으로 
16-bit Unicode로 결집된다. 아니면 각각의 바이트가 
현제의 멥핑 테이블에따라 옮겨진다( 이것은 Unicode 값으로
바뀐다).아래에서 CHARACTER SETS을 참조하자.
<P>

일반적인 경우, Unicode 값은 폰트 인덱스로 바뀌어서,
비디오 메모리에 저장된다. 그래서 대응하는 glyph
(비디오 ROM에 있는 것과 같이)가 화면에 나타난다.
Unicode의 사용(과 PC hardware의 디자인)에서는
512가지 다른 glyph를 동시에 사용할 수 있다.
<P>

현제 Unicode 값이 제어 문자라면, 혹은 현제 escape sequence
를 실행하고 있다면, 그 값은 특별히 다뤄질 것이다. 폰트 인덱스로
바뀌거나 glyph로 되는 대신, 커서를 움직이게 하거나 다른 제어 기능을 한다.
아래에서 LINUX CONSOLE CONTROLS 섹션을 보자.
<P>

hard-wire terminal control을 프로그램에 넣는 것은 일반적으로 좋은 일은 아니다.
리눅스는 터미널 기능의
<B><A HREF="http://localhost/cgi-bin/man/man2html?5+terminfo">terminfo</A></B>(5)

데이터 베이스를 지원한다.  
콘솔 escape 시퀀스를 직접 내보내는 것 보단, terminfo을 사용하려 할 것이다.
-스크린 라이브러리와.
<B><A HREF="http://localhost/cgi-bin/man/man2html?3+ncurses">ncurses</A></B>(3),

<B><A HREF="http://localhost/cgi-bin/man/man2html?1+tput">tput</A></B>(1),<B></B>

혹은
<B><A HREF="http://localhost/cgi-bin/man/man2html?1+reset">reset</A></B>(1).

를 알고 난다면.
<A NAME="lbAD">&nbsp;</A>
<H2>LINUX CONSOLE CONTROLS</H2>


이 섹션에선 리눅스 콘솔 상에서 특별한 기능들을(예를 들자면 
현제 커서 위치에서 plyph를 쓰는 것 같은) 하는 모든 제어문자와 
escape 시퀀스를 다루었다.
<A NAME="lbAE">&nbsp;</A>
<H3>Control characters</H3>

맵핑 테이블에 따라 변환되기 전에 
00 (NUL), 07 (BEL), 08 (BS), 09 (HT), 0a (LF), 0b (VT),
0c (FF), 0d (CR), 0e (SO), 0f (SI), 18 (CAN), 1a (SUB),
1b (ESC), 7f (DEL)와 같은 14가지 코드들 중 하나를 
가지고 있는 문자가 제어 문자이다.
`디스플레이 제어 문자' 모드를 설정할 수 있다 (아래 참조),
그리고 07, 09, 0b, 18, 1a, 7f는 glyph로 디스플레이 될 수 있다.
반면, 어떤 '디스플레이 제어 문자'에 관계없이 UTF-8 모드에선 
00-1f까지의 모든 문자를 제어 문자로 할 수 있다. 

제어 문자를 가지고 있다면, 그것은 즉시 적용되고 사라진다.
(그것이 escape 시퀀스 중에 있다 하더라도.)
그리고 escape 시퀀스는 다음 문자로 계속된다.
(하지만, ESC는 어떻게든 아직 끝나지 않은 이전의 것을 중지시키고, 
새로운 escape 시퀀스를 시작한다. 그리고 CAN과 SUB는 
어떤 escape 시퀀스라도 끝낸다.)
인증된 제어 문자는 BEL, BS, HT, LF, VT, FF, CR, SO, SI, 
CAN, SUB, ESC, DEL, CSI.이다. 이것들은 의도대로 동작한다: 
<DL COMPACT>
<DT>
<DD>BEL (0x07, ^G)은 소리를 낸다;
<DT>
<DD>BS (0x08, ^H)는 한 컬럼 역행한다.
(단, 행의 시작은 지나치지 않는다);
<DT>
<DD>HT (0x09, ^I)는 다음 텝의 마지막으로 가거나 
이전 텝의 마지막이 없다면 줄의 끝으로 간다;
<DT>
<DD>LF (0x0A, ^J), VT (0x0B, ^K)와 FF (0x0C, ^L)는 모두 개행 문자를 준다;
<DT>
<DD>CR (0x0D, ^M)은 케리지를 리턴한다;
<DT>
<DD>SO (0x0E, ^N)는 G1문자군을 활성화하고,
LF/NL (new line mode) 역시 케리지를 리턴시킨다;
<DT>
<DD>SI (0x0F, ^O)는 G0문자군을 활성화한다;
<DT>
<DD>CAN (0x18, ^X)과 SUB (0x1A, ^Z)는 escape 시퀀스를 중지시킨다;
<DT>
<DD>ESC (0x1B, ^[]는 escape  시퀀스를 시작한다;
<DT>
<DD>DEL (0x7F)은 무시된다;
<DT>
<DD>CSI (0x9B)는 ESC에 해당된다. [.
</DL>
<P>


<A NAME="lbAF">&nbsp;</A>
<H3>ESC-CSI가 아닌-시퀀스</H3>

<TABLE>
<TR VALIGN=top><TD>ESC c</TD><TD>RIS</TD><TD>리셋.<BR></TD></TR>
<TR VALIGN=top><TD>ESC D</TD><TD>IND</TD><TD>개행 문자.<BR></TD></TR>
<TR VALIGN=top><TD>ESC E</TD><TD>NEL</TD><TD>새 줄.<BR></TD></TR>
<TR VALIGN=top><TD>ESC H</TD><TD>HTS</TD><TD>텝을 현제 컬럼에 고정시킨다.<BR></TD></TR>
<TR VALIGN=top><TD>ESC M</TD><TD>RI</TD><TD>역 개행 문자.<BR></TD></TR>
<TR VALIGN=top><TD>ESC Z</TD><TD>DECID</TD><TD>DEC와 비슷. 커널은 스트링 ESC [ ? 6 c를 반환한다,<BR></TD></TR>
<TR VALIGN=top><TD><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이것은&nbsp;VT102임을&nbsp;요구한다.</TD><TD></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>ESC 7</TD><TD>DECSC</TD><TD>현제 상태를 저장한다. (커서의 좌표,<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD>속성, 문자군).<BR></TD></TR>
<TR VALIGN=top><TD>ESC 8</TD><TD>DECRC 가장 최근의 저장상태로 되돌린다.</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>ESC [</TD><TD>CSI</TD><TD>제어 시퀀스를 소개한다.<BR></TD></TR>
<TR VALIGN=top><TD>ESC %</TD><TD></TD><TD>선택한 문자군의 시퀀스를 시작한다.<BR></TD></TR>
<TR VALIGN=top><TD>ESC % @</TD><TD></TD><TD>&nbsp;&nbsp;&nbsp; 디폴트(ISO 646 / ISO 8859-1)를 선택한다<BR></TD></TR>
<TR VALIGN=top><TD>ESC % G</TD><TD></TD><TD>&nbsp;&nbsp;&nbsp; UTF-8을 선택한다.<BR></TD></TR>
<TR VALIGN=top><TD>ESC % 8</TD><TD></TD><TD>&nbsp;&nbsp;&nbsp; UTF-8 (obsolete)을 선택한다.<BR></TD></TR>
<TR VALIGN=top><TD>ESC # 8</TD><TD>DECALN</TD><TD>DEC 스크린 정렬 테스트 - 스크린을 E's으로 채운다.<BR></TD></TR>
<TR VALIGN=top><TD>ESC (</TD><TD></TD><TD>G0 문자군을 정의하는 시퀀스를 시작한다.<BR></TD></TR>
<TR VALIGN=top><TD>ESC ( B</TD><TD></TD><TD>&nbsp;&nbsp;&nbsp; 디폴트(ISO 8859-1 mapping)를 선택한다.<BR></TD></TR>
<TR VALIGN=top><TD>ESC ( 0</TD><TD></TD><TD>&nbsp;&nbsp;&nbsp; vt100 그래픽 맵핑을 선택한다.<BR></TD></TR>
<TR VALIGN=top><TD>ESC ( U</TD><TD></TD><TD>&nbsp;&nbsp;&nbsp; 널 맵핑을 선택한다. - 문자 ROM으로 바로ESC ( K<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD>&nbsp;&nbsp;&nbsp; <B><A HREF="http://localhost/cgi-bin/man/man2html?8+mapscrn">mapscrn</A></B>(8)유틸리티로 로드되는 맵.<BR></TD></TR>
<TR VALIGN=top><TD>ESC )</TD><TD></TD><TD>G1을 정의하는 시퀀스를 시작한다.<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD>(위와 같이 B, 0, U, K의 하나를 따라야 한다.).<BR></TD></TR>
<TR VALIGN=top><TD>ESC &gt;</TD><TD>DECPNM</TD><TD>숫자 키패드 모드를 설정한다<BR></TD></TR>
<TR VALIGN=top><TD>ESC =</TD><TD>DECPAM</TD><TD>어플리케이션 키패드 모드를 설정한다.<BR></TD></TR>
<TR VALIGN=top><TD>ESC ]</TD><TD>OSC</TD><TD>(Should be: 운영체제 명령어)<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD>ESC ] P <I>nrrggbb</I>: 색상표를 마지막 p 이후의 <BR></TD></TR>
<TR VALIGN=top><TD>7개의16 진수로 이루어진 매개 변수로 조절한다.</TD><TD></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD>여기서 <I>n</I> 은 색(0-16), 그리고 <BR></TD></TR>
<TR VALIGN=top><TD>적/녹/청 값(0-255)을 나타내는<I>rrggbb</I>이다. </TD><TD></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD>ESC ] R: 색상표를 리셋한다.<BR></TD></TR>
</TABLE>

<A NAME="lbAG">&nbsp;</A>
<H3>ECMA-48 CSI sequences</H3>


CSI (or ESC []는 세미콜론으로 구분되는 십진수 
매개 변수의(거의 NPAR(16)) 시퀀스로 실행된다. 
비어있는 매개 변수는 0값이 주어진다.
매개 변수의 시퀀셜은 앞에 하나의 물음표를 붙여놓았을 것이다.
<BR>&nbsp;
하지만, CSI [ (or ESC [ []뒤에선 문자 하나가 읽히고,
이 모든 시퀀스가 무시된다. (발상은 반항되는 기능키를 무시하는 것이다.)

CSI 시퀀스는 그것의 마지막 문자에 의해 결정된다.

<TABLE>
<TR VALIGN=top><TD>@</TD><TD>ICH</TD><TD>표시된 공간 문자의 수를 입력한다.<BR></TD></TR>
<TR VALIGN=top><TD>A</TD><TD>CUU</TD><TD>표시된 열의 수만큼 커서를 올린다.<BR></TD></TR>
<TR VALIGN=top><TD>B</TD><TD>CUD</TD><TD>표시된 열의 수만큼 커서를 내린다.<BR></TD></TR>
<TR VALIGN=top><TD>C</TD><TD>CUF</TD><TD>표시된 행의 수만큼 커서를 오른쪽으로 옮긴다.<BR></TD></TR>
<TR VALIGN=top><TD>D</TD><TD>CUB</TD><TD>표시된 행의 수만큼 커서를 왼쪽으로 옮긴다.<BR></TD></TR>
<TR VALIGN=top><TD>E</TD><TD>CNL</TD><TD>표시된 열의 수만큼 1행의 아래로 옮긴다.<BR></TD></TR>
<TR VALIGN=top><TD>F</TD><TD>CPL</TD><TD>표시된 열의 수만큼 1행의 위로 옮긴다.<BR></TD></TR>
<TR VALIGN=top><TD>G</TD><TD>CHA</TD><TD>현제 열에서 표시된 행으로 옮긴다..<BR></TD></TR>
<TR VALIGN=top><TD>H</TD><TD>CUP</TD><TD>표시된 행과 열로 커서를 옮긴다. (1,1에서 시작).<BR></TD></TR>
<TR VALIGN=top><TD>J</TD><TD>ED</TD><TD>화면을 지운다 (디폴트 값: 커서가 있는 곳부터 화면의 끝까지).<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD>ESC [ 1 J: 처음부터 커서가 있는 곳까지 지운다.<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD>ESC [ 2 J: 모든 화면을 다 지운다.<BR></TD></TR>
<TR VALIGN=top><TD>K</TD><TD>EL</TD><TD>줄을 지운다. (디폴트 값:커서에서부터 줄의 끝까지).<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD>ESC [ 1 K: 줄의 시작부터 커서가 있는 곳까지 지운다..<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD>ESC [ 2 K: 줄 전체를 지운다..<BR></TD></TR>
<TR VALIGN=top><TD>L</TD><TD>IL</TD><TD>표시된 수만큼 빈 줄을 삽입한다.<BR></TD></TR>
<TR VALIGN=top><TD>M</TD><TD>DL</TD><TD>지정된 수만큼의 줄을 지운다..<BR></TD></TR>
<TR VALIGN=top><TD>P</TD><TD>DCH</TD><TD>현제 줄에서 지정된 숫자만큼의 문자를 삭제한다.<BR></TD></TR>
<TR VALIGN=top><TD>X</TD><TD>ECH</TD><TD>현제 줄에서 지정된 숫자만큼의 문자를 지운다.<BR></TD></TR>
<TR VALIGN=top><TD>a</TD><TD>HPR</TD><TD>표시된 행만큼 커서를 오른쪽으로 옮긴다.<BR></TD></TR>
<TR VALIGN=top><TD>c</TD><TD>DA</TD><TD>ESC [ ? 6 c: 에게 `VT102다.'라고 답한다'.<BR></TD></TR>
<TR VALIGN=top><TD>d</TD><TD>VPA</TD><TD>현제 행에서 지정된 열만큼 옮긴다.<BR></TD></TR>
<TR VALIGN=top><TD>e</TD><TD>VPR</TD><TD>지정된 열만큼 내린다..<BR></TD></TR>
<TR VALIGN=top><TD>f</TD><TD>HVP</TD><TD>지정된 열과 행으로 움직인다.<BR></TD></TR>
<TR VALIGN=top><TD>g</TD><TD>TBC</TD><TD>매개 변수없이: 현제 위치에서 텝을 지운다..<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD>ESC [ 3 g: 모든 텝을 지운다..<BR></TD></TR>
<TR VALIGN=top><TD>h</TD><TD>SM</TD><TD>모드를 설정한다 (아래 참조).<BR></TD></TR>
<TR VALIGN=top><TD>l</TD><TD>RM</TD><TD>모드를 리셋한다 (아래 참조).<BR></TD></TR>
<TR VALIGN=top><TD>m</TD><TD>SGR</TD><TD>속성을 설정한다 (아래 참조).<BR></TD></TR>
<TR VALIGN=top><TD>n</TD><TD>DSR</TD><TD>상태 보고 (아래 참조).<BR></TD></TR>
<TR VALIGN=top><TD>q</TD><TD>DECLL</TD><TD>키보드 LED를 .<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD>ESC [ 0 q: 모든 LED를 끈다.<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD>ESC [ 1 q: Scroll Lock LED를 설정한다.<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD>ESC [ 2 q: Num Lock LED를 설정한다.<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD>ESC [ 3 q: Caps Lock LED를 설정한다<BR></TD></TR>
<TR VALIGN=top><TD>r</TD><TD>DECSTBM</TD><TD>스크롤 영역을 설정한다; 매개 변수는 첫 열과 끝 열.<BR></TD></TR>
<TR VALIGN=top><TD>s</TD><TD>?</TD><TD>커서의 위치를 저장한다..<BR></TD></TR>
<TR VALIGN=top><TD>u</TD><TD>?</TD><TD>커서의 위치를 재지정한다..<BR></TD></TR>
<TR VALIGN=top><TD>`</TD><TD>HPA</TD><TD>커서를 현제 열의 지정한 행으로 옮긴다..<BR></TD></TR>
</TABLE>

<A NAME="lbAH">&nbsp;</A>
<H3>ECMA-48 Set Graphics Rendition</H3>


The ECMA-48 SGR 시퀀스 ESC [ &lt;parameters&gt; m 디스플레이 속성을 설정한다.
몇가지 속성은 같은 시퀀스에서 설정할 수 있다.
<P>

<TABLE>
<TR VALIGN=top><TD>par</TD><TD>결과<BR></TD></TR>
<TR VALIGN=top><TD>0</TD><TD>모든 속성을 디폴트로 리셋한다.<BR></TD></TR>
<TR VALIGN=top><TD>1</TD><TD>볼드체로 설정한다.<BR></TD></TR>
<TR VALIGN=top><TD>2</TD><TD>밝기(색 디스플레이에서 시뮬레이트 된 색)를 반으로 설정한다.<BR></TD></TR>
<TR VALIGN=top><TD>4</TD><TD>배경을 설정한다 (색 디스플레이에서 시뮬레이트 된 색)<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD>(딤이나 언더라인을 시뮬레트 할 떄 쓰는 색은 ESC를 사용하여 설정해준다<BR></TD></TR>
<TR VALIGN=top><TD>5</TD><TD>깜빡임을 설정한다.<BR></TD></TR>
<TR VALIGN=top><TD>7</TD><TD>리버스 비디오를 설정한다<BR></TD></TR>
<TR VALIGN=top><TD>10</TD><TD>선택된 맵핑과 디스플레이 제어 플래그 그리고 <BR></TD></TR>
<TR VALIGN=top><TD>토글 메타 플래그를 리셋한다. </TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>11</TD><TD>널 맵핑을 선택하고, 디스플레이 제어 플래그를 설정하고<BR></TD></TR>
<TR VALIGN=top><TD>토글 메타 플래그를 리셋한다</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>12</TD><TD>널 맵핑을 선택하고, 디스플레이 제어 플래그를 설정하고,<BR></TD></TR>
<TR VALIGN=top><TD>토글 메타 플래그를 설정한다.(토글 메타 플래그는 </TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>맵핑 테이블 해석이 끝나기 전에 토글된 바이트의 </TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>하이 비트를 생기게 하는 원인이 된다.)</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>21</TD><TD>일반적인 세기를 설정한다. (이것은 ECMA-48와 맞지 않는다.)<BR></TD></TR>
<TR VALIGN=top><TD>22</TD><TD>일반적인 세기를 설정한다.<BR></TD></TR>
<TR VALIGN=top><TD>24</TD><TD>언더라인 끄기<BR></TD></TR>
<TR VALIGN=top><TD>25      깜빡임 끄기</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>27</TD><TD>리버스 비디오 끄기<BR></TD></TR>
<TR VALIGN=top><TD>30</TD><TD>검은색 전경 설정<BR></TD></TR>
<TR VALIGN=top><TD>31</TD><TD>붉은색 전경 설정<BR></TD></TR>
<TR VALIGN=top><TD>32</TD><TD>녹색 전경 설정<BR></TD></TR>
<TR VALIGN=top><TD>33</TD><TD>갈색 전경 설정<BR></TD></TR>
<TR VALIGN=top><TD>34</TD><TD>파란색 전경 설정<BR></TD></TR>
<TR VALIGN=top><TD>35</TD><TD>자홍색 전경 설정<BR></TD></TR>
<TR VALIGN=top><TD>36</TD><TD>청록색 전경 설정<BR></TD></TR>
<TR VALIGN=top><TD>37</TD><TD>하얀색 화경 설정<BR></TD></TR>
<TR VALIGN=top><TD>38</TD><TD>배경을 켠다, 기본 전경 색을 설정한다.<BR></TD></TR>
<TR VALIGN=top><TD>39</TD><TD>배경을 끈다, 기본 전경 색을 설정한다.<BR></TD></TR>
<TR VALIGN=top><TD>40</TD><TD>검은색 배경 설정<BR></TD></TR>
<TR VALIGN=top><TD>41</TD><TD>붉은색 배경 설정<BR></TD></TR>
<TR VALIGN=top><TD>42</TD><TD>녹색 배경 설정<BR></TD></TR>
<TR VALIGN=top><TD>43</TD><TD>갈색 배경 설정<BR></TD></TR>
<TR VALIGN=top><TD>44</TD><TD>파란색 배경 설정<BR></TD></TR>
<TR VALIGN=top><TD>45</TD><TD>자홍색 배경 설정<BR></TD></TR>
<TR VALIGN=top><TD>46</TD><TD>청록색 배경 설정<BR></TD></TR>
<TR VALIGN=top><TD>47</TD><TD>하얀색 배경 설정<BR></TD></TR>
<TR VALIGN=top><TD>49</TD><TD>기본 배경 설정<BR></TD></TR>
</TABLE>

<A NAME="lbAI">&nbsp;</A>
<H3>ECMA-48 Mode Switches</H3>

<DL COMPACT>
<DT>ESC [ 3 h<DD>
DECCRM (default off): 디스플레이 설정 chars.
<DT>ESC [ 4 h<DD>
DECIM (default off): 삽입 모드 설정.
<DT>ESC [ 20 h<DD>
LF/NL (default off): 자동적으로 LF, VT 혹은 CR과 FF의 에코를 발생.
</DL>
<P>

<A NAME="lbAJ">&nbsp;</A>
<H3>ECMA-48 Status Report Commands</H3>

<DL COMPACT>
<DT>ESC [ 5 n<DD>
Device status report (DSR): 응답은 ESC [ 0 n (Terminal OK).
<DT>ESC [ 6 n<DD>
Cursor position report (CPR): 응답은 ESC [ <I>y</I> ; <I>x</I> R,
where <I>x,y</I> is the cursor location.

</DL>
<A NAME="lbAK">&nbsp;</A>
<H3>DEC Private Mode (DECSET/DECRST) sequences.</H3>


ECMA-48에 대한 설명은 없다. Set Mode sequences를 리스트에 올렸다;
Reset Mode sequences는 마지막`h'를 `l'로 바꾸면 된다..
<DL COMPACT>
<DT>ESC [ ? 1 h<DD>
DECCKM (default off): 설정되면, 커서키는 ESC보다 ESC O 접두사를 보낸다[.
<DT>ESC [ ? 3 h<DD>
DECCOLM (default off = 80 columns): 80/132 col mode switch. 드라이버 소스에 의하면
이것만으로는 충분치 못하다고 한다;
<B><A HREF="http://localhost/cgi-bin/man/man2html?8+resizecons">resizecons</A></B>(8)

와 같은 유저 모드의 유틸리티가 콘솔 비디오 카드상의 하드웨어 레지스터를 바꿔야만 한다.
<DT>ESC [ ? 5 h<DD>
DECSCNM (default off): 리버스 비디오 모드를 설정한다.
<DT>ESC [ ? 6 h<DD>
DECOM (default off): 설정하면, 커서 어드레싱은 스크롤링 구역의 상위 왼쪽 코너와 관련된다.
<DT>ESC [ ? 7 h<DD>
DECAWM (default on):autowrap을 켜진 상태로 설정한다. 이 모드에서는, 80열(DECCOLM
이 켜졌을때는 132열)후에 나온 그래픽 문자가 다음 열의 시작을 밀어낸다.
<DT>ESC [ ? 8 h<DD>
DECARM (default on): 키보드 자동 반복을 켠다.
<DT>ESC [ ? 9 h<DD>
X10 Mouse Reporting (default off): 리포팅 모드를 1로 설정한다.(혹은 0을
리셋한다.) - 아래를 참조.
<DT>ESC [ ? 25 h<DD>
DECCM (default on): 커서를 보이게 한다.
<DT>ESC [ ? 1000 h<DD>
X11 Mouse Reporting (default off): 리포팅 모드를 2로 설정한다.(혹은 0으로
리셋한다.) - 아래 참조.

</DL>
<A NAME="lbAL">&nbsp;</A>
<H3>Linux Console Private CSI Sequences</H3>


아래 시퀀스들은 ECMA-48도 VT102도 아니다. 이것은 리눅스 콘솔 드라이버
고유의 것들이다. 색은 SGR 매개 변수에 있다:
0 = 검은색, 1 = 붉은색, 2 = 초록색, 3 = 갈색, 4 = 파란색, 5 = 자홍색, 6 =
청록색, 7 = 하얀색.

<TABLE>
<TR VALIGN=top><TD>ESC [ 1 ; <I>n</I> ]</TD><TD><I>n</I>에 해당하는 색을 언더라인 색으로 설정한다.<BR></TD></TR>
<TR VALIGN=top><TD>ESC [ 2 ; <I>n</I> ]</TD><TD><I>n</I>에 해당하는 색을 딤 색으로 설정한다.<BR></TD></TR>
<TR VALIGN=top><TD>ESC [ 8 ]       </TD><TD>현제 색을 디폴트 속성과 한쌍으로 만든다.<BR></TD></TR>
<TR VALIGN=top><TD>ESC [ 9 ; <I>n</I> ]</TD><TD>화면 공백의 간격을 <I>n</I>분으로 설정한다.<BR></TD></TR>
<TR VALIGN=top><TD>ESC [ 10 ; <I>n</I> ]</TD><TD>벨의 주파수를 Hz로 설정한다..<BR></TD></TR>
<TR VALIGN=top><TD>ESC [ 11 ; <I>n</I> ]</TD><TD>벨의 지속시간을 msec으로 설정한다.<BR></TD></TR>
<TR VALIGN=top><TD>ESC [ 12 ; <I>n</I> ]</TD><TD>열거된 콘솔을 앞으로 가져온다.<BR></TD></TR>
<TR VALIGN=top><TD>ESC [ 13 ]      </TD><TD>화면 공백을 없앤다.<BR></TD></TR>
<TR VALIGN=top><TD>ESC [ 14 ; <I>n</I> ]   </TD><TD>VESA 파워다운 간격을 분으로 설정한다.<BR></TD></TR>
</TABLE>


<A NAME="lbAM">&nbsp;</A>
<H2>CHARACTER SETS</H2>


커널은 콘솔상에서 바이트의 변환을 4개정도 구분한다.
그 4가지 테이블은 아래와 같다: a) Latin1 -&gt; PC,  b) VT100 graphics -&gt; PC, c) PC -&gt; PC,
d) 사용자 정의.

G0과 G1이라 불리는 두가지 문자군 (character sets)이 있고, 그중 하나가 
현제 통용되는 문자군이다.(보통 G0)
^N을 입력함으로써 G1을 사용할 수 있다.^O을 입력하면 G0으로 바뀐다.

이 가변적인 G0과 G1은 변환 테이블을 말하고, 사용자가 바꿀 수 있다.
처음에 그것들은 각각 테이블 a)와 b)를 뜻했다.
ESC ( B, ESC ( 0, ESC ( U와 ESC ( K 시퀀스들은 각각 G0가 
변환 테이블 a), b), c)와 d)를 가르키도록 한다.
ESC ) B, ESC ) 0, ESC ) U와 ESC ) K 시퀀스는 G1이 
각각 테이블 a), b), c) 그리고 d)을 뜻하게 한다.

ESC c 시퀀스는 터미널을 리셋시킨다. 이것은 화면이 왜곡되었을 때 사용한다
&quot;echo ^V^O&quot;는 G0상에서만 작동한다. 하지만 G0가 테이블 a)를 지정한다는 보장은 없다.
어떤 배포판에선 &quot;echo ^[c&quot;에만 적용되는 프로그램
<B><A HREF="http://localhost/cgi-bin/man/man2html?1+reset">reset</A></B>(1)

이 있다.
만약 당신의 콘솔을 위한 terminfo entry가 정확하다면
(그리고 entry rs1=\Ec를 가지고 있다면), &quot;tput reset&quot; 역시 작동할 것이다.

사용자 정의 맵핑 테이블은 
<B><A HREF="http://localhost/cgi-bin/man/man2html?8+mapscrn">mapscrn</A></B>(8).

을 이용해 설정할 수 있다.
맵핑의 결과는 기호 c가 프린트되면, 기호 s = map[c] 가 비디오 메모리로 보내진다
s에 해당하는 비트멥을 문자 ROM에서 찾고, 
<B><A HREF="http://localhost/cgi-bin/man/man2html?8+setfont">setfont</A>(8).</B>

사용이 바뀔 수 있게 된다
<A NAME="lbAN">&nbsp;</A>
<H2>MOUSE TRACKING</H2>


마우스 추적 기능의 원래 목적은 xterm(마우스 호환 상태 리포트)을 반환하는 것이다. 
콘솔 드라이버는 마우스 장치나, 타입을 알 수 없기 때문에, 가상 터미널 드라이버가 마우스 
업데이트 ioctl을 받았을때만 콘솔 입력 스트림상에서 이 리포트가 반환된다. 
이 ioctls은 반드시 <B><A HREF="http://localhost/cgi-bin/man/man2html?8+gpm">gpm</A>(8)</B> 데몬과 같은 mouse-aware user-mode 어플리케이션에 의해
발생되어야 한다.

<I>xterm</I>에 의해 생성된 모든 마우스 추적 escape 시퀀스를 위한 매개 변수는 수치적인 매개 변수를 <I>value</I>+040와 같은 하나의 문자로 인코딩 한다. 예를 들면, `!'는 1이다. 스크린 좌표 시스템은 1-based.이다 
X10 호환 모드는 escape sequence를 위치와 눌려진 마우스 버튼을 
인코딩한 버튼이 눌러졌을 때 보낸다.
It is enabled by ESC [ ? 9 h를 보냄으로써 이것을 가능하게 하고, 
ESC [ ? 9 l를 보냄으로써 불가능 하게 한다..
button press에서 , <I>xterm</I>은 ESC [ M <I>bxy</I> (6 characters)를 보낸다.  
<I>b</I> 는 버튼-1이고, 마우스를 눌렀을 때의 <I>x</I>와 <I>y</I>는 마우스의 x, y좌표이다. 
이 코드는 모든 커널에서 적용된다.
<BR>&nbsp;
노말 추적 모드(Linux 2.0.24에서 실행되지 않는)는 escape 시퀀스를 버튼을 누를 때와 띨 때 모두 보낸다. 수정 정보 역시 보낸다. 이것은 ESC [ ? 1000 h를 보냄으로써 가능해지고 ESC [ 1000 l을 보냄으로써 불가능해 진다. 버튼을 누를 때나 띨 때, <I>xterm</I>은 ESC [ M <I>bxy</I>를 보낸다.
<I>b</I>의 아래 두 비트는 버튼 정보를 인코드한다:
0=MB1 pressed, 1=MB2 pressed, 2=MB3 pressed, 3=release.  상위 두 비트는 버튼을
눌렀을때 어떤 수정이 가해졌는지를 인코딩하고, 그것을 다 합친다: 4=Shift, 8=Meta, 16=Control.  
다시 <I>x</I>와 <I>y</I>는 마우스 움직임의 x,y 좌표가 된다. 
상위 왼쪽 코너는 (1,1)이라.

<A NAME="lbAO">&nbsp;</A>
<H2>COMPARISONS WITH OTHER TERMINALS</H2>


많은 서로 다른 터미널 타입은 리눅스 콘솔이 VT100 호환 인 것 처럼 묘사된다.
리눅스 콘설과 다른 가장 중요한 두가지 DEC VT102와
<B><A HREF="http://localhost/cgi-bin/man/man2html?1+xterm">xterm</A></B>(1).

의 차이점에 대해 알아보자.
<A NAME="lbAP">&nbsp;</A>
<H3>Control-character handling</H3>

vt102 역시 아래 제어 문자들을 인식한다:
<DL COMPACT>
<DT>
<DD>NUL (0x00) 은 무시한다;
<DT>
<DD>ENQ (0x05) 응답 메시지를 트리거 한다;
<DT>
<DD>DC1 (0x11, ^Q, XON) 전송을 재개한다;
<DT>
<DD>DC3 (0x13, ^S, XOFF) vt100으로 하여금 XOFF와 XON을 제외한 
모든 코드를 무시한다(그리고 전송을 멈춘다)
</DL>
<P>

VT100-DC1/DC3 과정과 비슷한, 는 tty 드라이버에 의해 작동 가능하다.
<P>

<I>xterm</I>

프로그램(vt100 모드에서)은 BEL, BS, HT, LF, VT, 
FF, CR, SO, SI, ESC 제어 문자를 인식한다.

<A NAME="lbAQ">&nbsp;</A>
<H3>Escape sequences</H3>

VT100 콘솔 시퀀스는 리눅스 콘솔에서 실행되지 않는다.
<P>

<TABLE>
<TR VALIGN=top><TD>ESC N</TD><TD>SS2</TD><TD>Single shift 2. (다음 문자를 위해 G2 문자군을 선택한다)<BR></TD></TR>
<TR VALIGN=top><TD>ESC O</TD><TD>SS3</TD><TD>Single shift 3. (다음 문자를 위해 G3 문자군을 선택한다)<BR></TD></TR>
<TR VALIGN=top><TD>ESC P</TD><TD>DCS</TD><TD>Device control string (ESC \에 의해 가능해진다)<BR></TD></TR>
<TR VALIGN=top><TD>ESC X</TD><TD>SOS</TD><TD>스트링을 시작한다.<BR></TD></TR>
<TR VALIGN=top><TD>ESC ^</TD><TD>PM</TD><TD>사적인 메시지 (ESC \로 끝난다)<BR></TD></TR>
<TR VALIGN=top><TD>ESC \</TD><TD>ST</TD><TD>스트링 종료기<BR></TD></TR>
<TR VALIGN=top><TD>ESC * ...</TD><TD></TD><TD>G2 문자군을 지정한다.<BR></TD></TR>
<TR VALIGN=top><TD>ESC + ...</TD><TD></TD><TD>G3 문자군을 지정한다.<BR></TD></TR>
</TABLE>


프로그램
<I>xterm</I>

(vt100 모드에서)는 ESC c, ESC # 8, ESC &gt;, ESC =,ESC D, ESC E, 
ESC H, ESC M, ESC N, ESC O, ESC P ... ESC ,ESC Z 를 인식한다.
(ESC [ ? 1 ; 2 c, `I am a vt100 with advanced video option'라고 대답한다]
ESC ^ ... ESC 도 위와 같은 메시지와 함께 인식가능 하다.
이것은 ESC (, ESC ), ESC *,  ESC + 도 각각 DEC 특수 문자, 
line drawing set, UK, USASCII로 인식한다.
ESC ]는 현제 리소스의 설정으로 인식한다:
<P>

<TABLE>
<TR VALIGN=top><TD>ESC ] 0 ; txt BEL</TD><TD>아이콘 이름과 창 이름을 txt로 설정한다.ESC ] 1 ; txt BEL<BR></TD></TR>
<TR VALIGN=top><TD>ESC ] 2 ; txt BEL</TD><TD>창 이름을 txt로 설정한다.<BR></TD></TR>
<TR VALIGN=top><TD>ESC ] 4 6 ; name BEL</TD><TD>로그파일을 이름으로 바꾼다. (일반적으로 <BR></TD></TR>
<TR VALIGN=top><TD>compile-time 옵션에 의해 불가능하다.)</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>ESC ] 5 0 ; fn BEL</TD><TD>폰트를 fn으로 설정한다.<BR></TD></TR>
</TABLE>


아래에 있는 것들은 약간 의미가 바뀌어서 인식된다:
<P>

<TABLE>
<TR VALIGN=top><TD>ESC 7  DECSC</TD><TD>커서 저장</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>ESC 8  DECRC</TD><TD>커서 복원</TD><TD><BR></TD></TR>
</TABLE>


It also recognizes
<P>

<TABLE>
<TR VALIGN=top><TD>ESC F</TD><TD></TD><TD>커서를 스크린의 좌측 하단으로 옮긴다.<BR></TD></TR>
<TR VALIGN=top><TD>( hpLowerleftBugCompat 리소스에 의해 가능해지면) </TD><TD></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>ESC l</TD><TD></TD><TD>메모리 잠금 (HP 터미널 당).<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD>커서상에서 메모리를 잠근다.<BR></TD></TR>
<TR VALIGN=top><TD>ESC m</TD><TD></TD><TD>메모리 개방(HP 터미널 당).<BR></TD></TR>
<TR VALIGN=top><TD>ESC n</TD><TD>LS2</TD><TD>G2 문자군을 부른다.<BR></TD></TR>
<TR VALIGN=top><TD>ESC o</TD><TD>LS3</TD><TD>G3 문자군을 부른다.ESC |<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD>Xterm상에서 눈에 보이는 변화는 없음.<BR></TD></TR>
<TR VALIGN=top><TD>ESC }</TD><TD>LS2R</TD><TD>G2 문자군을 GR로서 부른다.<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD>Xterm상에서 눈에 보이는 변화는 없음.<BR></TD></TR>
<TR VALIGN=top><TD>ESC ~</TD><TD>LS1R</TD><TD>G1 문자군을 GR로서 부른다.<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD>Xterm상에서 눈에 보이는 변화는 없음..<BR></TD></TR>
</TABLE>


ESC % ...는 인식하지 못한다.

<A NAME="lbAR">&nbsp;</A>
<H3>CSI Sequences</H3>

<I>xterm</I>

프로그램은 (XFree86 3.1.2G의 경우) 깜빡임이나 보이지 않는 모드의 SGR을 인식하지 못한다.
주요 X11R6 버전은 칼라 셋팅의 SGR을 인식하지 못한다.
리눅스에서 인식하는 다른 모든ECMA-48 CSI 시퀀스는 
<I>xterm</I>,

와 vice-versa에서도 역시 인식된다..

<I>xterm</I>

프로그램은 모든 DEC Private Mode 시퀀스를 인식할 것이다. 위의 목록을 참조하자.
하지만 Linux private-mode 시퀀스는 인식하지 못한다.
<I>xterm</I>

자신의 private-mode 시퀀스에 대해선, Edward Moy와 Stephen Gildea가 쓴 
<I>Xterm Control Sequences</I>

문서를 참조하자

<A NAME="lbAS">&nbsp;</A>
<H2>BUGS</H2>


2.0.23 버전에서, CSI가 작동하지않고, NUL은 내부 escape 시퀀스를 무시하지 않는다.

<A NAME="lbAT">&nbsp;</A>
<H2>SEE ALSO</H2>

<B><A HREF="http://localhost/cgi-bin/man/man2html?4+console">console</A></B>(4),

<B><A HREF="http://localhost/cgi-bin/man/man2html?4+console_ioctl">console_ioctl</A></B>(4),

<B><A HREF="http://localhost/cgi-bin/man/man2html?7+charsets">charsets</A></B>(7)


<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">DESCRIPTION</A><DD>
<DT><A HREF="#lbAD">LINUX CONSOLE CONTROLS</A><DD>
<DL>
<DT><A HREF="#lbAE">Control characters</A><DD>
<DT><A HREF="#lbAF">ESC-CSI가 아닌-시퀀스</A><DD>
<DT><A HREF="#lbAG">ECMA-48 CSI sequences</A><DD>
<DT><A HREF="#lbAH">ECMA-48 Set Graphics Rendition</A><DD>
<DT><A HREF="#lbAI">ECMA-48 Mode Switches</A><DD>
<DT><A HREF="#lbAJ">ECMA-48 Status Report Commands</A><DD>
<DT><A HREF="#lbAK">DEC Private Mode (DECSET/DECRST) sequences.</A><DD>
<DT><A HREF="#lbAL">Linux Console Private CSI Sequences</A><DD>
</DL>
<DT><A HREF="#lbAM">CHARACTER SETS</A><DD>
<DT><A HREF="#lbAN">MOUSE TRACKING</A><DD>
<DT><A HREF="#lbAO">COMPARISONS WITH OTHER TERMINALS</A><DD>
<DL>
<DT><A HREF="#lbAP">Control-character handling</A><DD>
<DT><A HREF="#lbAQ">Escape sequences</A><DD>
<DT><A HREF="#lbAR">CSI Sequences</A><DD>
</DL>
<DT><A HREF="#lbAS">BUGS</A><DD>
<DT><A HREF="#lbAT">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 08:07:01 GMT, March 25, 2004
</BODY>
</HTML>
