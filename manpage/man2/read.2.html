<HTML><HEAD><TITLE>Manpage of READ</TITLE>
</HEAD><BODY>
<H1>READ</H1>
Section: 리눅스 프로그래머 매뉴얼 (2)<BR>Updated: 1997년 6월 12일<BR><A HREF="#index">Index</A>
<BR />
<A HREF="http://localhost/cgi-bin/man/man2html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>이름</H2>

read - 파일 기술자(file descriptor)를 통해서 읽어들인다.
<A NAME="lbAC">&nbsp;</A>
<H2>사용법</H2>

<PRE>
<B>#include &lt;<A HREF="file:/usr/include/unistd.h">unistd.h</A>&gt;</B>

<B>ssize_t read(int </B><I>fd</I><B>, void *</B><I>buf</I><B>, size_t </B><I>count</I><B>);</B>
</PRE>

<A NAME="lbAD">&nbsp;</A>
<H2>설명</H2>

<B>read()</B>는

파일 기술자
<I>fd</I>에서

<I>buf</I>로

시작하는 버퍼에 
<I>count</I>

바이트까지 읽기를 시도한다.
<P>

만일
<I>count</I>가

0이라면 <B>read()</B>는 0을 반환하며 다른 결과는 가지지 않는다.
만일
<I>count</I>가

SSIZE_MAX보다 크다면, 결과는 예측할 수 없다.
<P>

<A NAME="lbAE">&nbsp;</A>
<H2>반환값</H2>

성공시, 읽은 바이트 수를 반환하며(0은 파일의 끝을 나타낸다.)
파일 포인터의 위치는 읽은 수만큼 이동된다.
만일 이 수가 요구된 바이트의 수보다 작더라도 에러는 아니다;
이것은 실제로 즉시 이용할 수 있는 바이트가 거의 없기 때문이거나 
(아마도 이것은 파일의 끝이어서 닫았거나 파이프나 단말기에서 읽기 
때문이다.) <B>read()</B>가 어떤 신호에 의해 인터럽트가 되었기 때문이다.
<P>
에러시, -1을 리턴하며
<I>errno</I>는

적당한 값으로 설정된다.
이 경우 파일 포인터의 위치가 바뀔지 어떨지는 예측할수 없다.
<A NAME="lbAF">&nbsp;</A>
<H2>에러</H2>

<DL COMPACT>
<DT><B>EINTR</B>

<DD>
어떤 데이터를 읽기도 전에 함수가 신호에 의해 인터럽트되었다.
<DT><B>EAGAIN </B>

<DD>
넌-블록킹 I/O가 
<B>O_NONBLOCK</B>을

사용하여 선택되어졌고 즉시 읽을 수 있는 데이터가 없다.
<DT><B>EIO</B>

<DD>
I/O 에러. 이것은 백그라운드 프로세스 그룹에 있는 프로세스가 
제어되는 tty 단말기에서 읽기를 시도할때, 그리고 이것이 무시되거나 
봉쇄되는 SIGTTIN이거나 또는 프로세스 그룹이 고아일때 일어난다.
또한 디스크나 테이프에서 읽는동안 저레벨(low-level) I/O 에러가
있을 때 일어난다.
<DT><B>EISDIR</B>

<DD>
<I>fd</I>가

디렉토리를 가리킨다.
<DT><B>EBADF</B>

<DD>
<I>fd</I>가

유효한 파일 기술자가 아니거나 읽기 위해 열려지지 않았다.
<DT><B>EINVAL</B>

<DD>
<I>fd</I>가

읽기에 적당하지 않은 객체와 연결되었다.
<DT><B>EFAULT</B>

<DD>
<I>buf</I>는

접근할 수 없는 주소공간을 가리키고 있다.
</DL>
<P>

<I>fd</I>에

접속된 객체에 의존하여 다른 에러가 일어날 수 있다.
POSIX는 데이터 일부를 읽은 후 인터럽트 되었을 경우
<B>read</B>가

-1이나(
<I>errno</I>는

EINTR로 설정된다.) 이미 읽은 바이트의 수를 리턴하도록 허용한다.
<A NAME="lbAG">&nbsp;</A>
<H2>호환</H2>

SVr4, SVID, AT&amp;T, POSIX, X/OPEN, BSD 4.3
<A NAME="lbAH">&nbsp;</A>
<H2>RESTRICTIONS</H2>

NFS 파일 시스템에서, 읽은 적은 양의 데이터는 단지 처음 타임 스탬프에서만
갱신되며 연속적인 콜은 그렇게 하지 않는다.
이것은 캐싱(caching)하는 클라이언트 쪽 특성 때문인데, 모든 NFS 
클라이언트가 서버에 접근 시간(atime) 갱신을 하지는 않으며 
클라이언트 쪽 캐쉬에서 읽기를 한 클라이언트는 서버 쪽 읽기가 없기
때문에 서버에 접근시간 갱신을 하지 않기 때문이다.
UNIX 구문은 클라이언트 쪽 캐싱 특성을 불가능하게 하여 얻어지며 
이것은 대부분의 상황에서 서버 부하를 증가시키고 성능을 감소시킨다.
<A NAME="lbAI">&nbsp;</A>
<H2>관련 항목</H2>

<B><A HREF="http://localhost/cgi-bin/man/man2html?2+close">close</A></B>(2),

<B><A HREF="http://localhost/cgi-bin/man/man2html?2+fcntl">fcntl</A></B>(2),

<B><A HREF="http://localhost/cgi-bin/man/man2html?2+ioctl">ioctl</A></B>(2),

<B><A HREF="http://localhost/cgi-bin/man/man2html?2+lseek">lseek</A></B>(2),

<B><A HREF="http://localhost/cgi-bin/man/man2html?2+readdir">readdir</A></B>(2),

<B><A HREF="http://localhost/cgi-bin/man/man2html?2+readlink">readlink</A></B>(2),

<B><A HREF="http://localhost/cgi-bin/man/man2html?2+select">select</A></B>(2),

<B><A HREF="http://localhost/cgi-bin/man/man2html?2+write">write</A></B>(2),

<B><A HREF="http://localhost/cgi-bin/man/man2html?3+fread">fread</A></B>(3)

<A NAME="lbAJ">&nbsp;</A>
<H2>역자</H2>

정강훈 &lt;<A HREF="mailto:skyeyes@soback.kornet.net">skyeyes@soback.kornet.net</A>&gt;, 2000년 5월 28일
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">이름</A><DD>
<DT><A HREF="#lbAC">사용법</A><DD>
<DT><A HREF="#lbAD">설명</A><DD>
<DT><A HREF="#lbAE">반환값</A><DD>
<DT><A HREF="#lbAF">에러</A><DD>
<DT><A HREF="#lbAG">호환</A><DD>
<DT><A HREF="#lbAH">RESTRICTIONS</A><DD>
<DT><A HREF="#lbAI">관련 항목</A><DD>
<DT><A HREF="#lbAJ">역자</A><DD>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 08:07:00 GMT, March 25, 2004
</BODY>
</HTML>
